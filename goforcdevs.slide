Golang for C developers

Federico Paolinelli
List
@fedepaol
fedepaol@gmail.com


* About me

- Lead developer at List
- Not a Go expert

Things I tinker with in my spare time:

- Android
- Some Python

* Why I started this journey

We do distributed systems, and we (also) use C

Go's elevator pitch:

- fast
- good at networking and multiprocessing
- scales well

* On top of that, Go claims to be

- comprehensible
- statically typed
- fast to work in
- doesn't require tools, but supports them well

* Let's talk about C
: niche use cases
: the "latin" of programming languages

* Very simple

You have Structs
.code structs.c

and functions
.code functions.c

and that's it.
No objects, inheritance, polymorphism.

* Oh, and you have pointers
.code pointers.c
Direct access to memory locations. 
It's only way to pass references around instead of copies.

* What I like about C
- direct control of things (pointers!)
- no hidden costs
- *you*understand*what*you*are*reading*

* What I don't like about C
- *verbose*
- easy to shoot on your foot
- limited standard library
- dependency management

*Do*we*always*need*that*kind*of*control?*

: memory leaks, direct access to memory
: if you need a data structure, you need to reimplement it or rely on external libraries

* The recipe for Go

- Go back to the 70s / 80s and find a bunch of great programmers. Say, Ken Thompson, Rob Pike, people like that. Marinate them in Bell Labs for 30 years, during which time they code in C, keep developing Unix, invent Plan 9, UTF-8, and other wonderful things.

- Take them out, seduce them with Python, wow them with Google-scale computing. Add more amazing programmers (Brad Fitzpatrick for example), stir in Googleâ€™s near-unlimited resources.

- Ask them how they would do C now, if they could start from scratch.

.caption _credits_ by [[https://www.darkcoding.net/software/go-lang-after-four-months/][Graham King]]

* What I did expect from Go

* Other languages I (barely) know
Kotlin
.code sample.kt

Javascript
.code sample.js

Java
.code sample.java

* Doing a lot with few lines of code

.image lambdas.jpg 400 _

: languages as products. They copy each others and keep adding features
: Too dense!

* What I found

Simple apply/filter/reduce package by Rob Pike:

.link https://github.com/robpike/filter

From the repo readme:
I wanted to see how hard it was to implement this sort of thing in Go, with as nice an API as I could manage. It wasn't hard.
Having written it a couple of years ago, I haven't had occasion to use it once.
 *Instead*,*I*just*use*"for"*loops.*
You shouldn't use it either.

.image run.png

* Go focuses on
- being explicit rather than implicit
- being readable
- getting sh*t done

* Let's dive in

* Basic data types

As in C, we do have integers, floats, booleans:
.code basictypes.go

Go provides a higher level _string_ type:

.code strings.go

Implicit casts are not allowed

.code basictypes2.go

* Arrays in C:
.code arrays.c

- length is not a property
- shortcut for pointer arithmetic (non initialized, out of bound errors write in memory)

* Arrays in Go: 
.code arrays.go

- Fixed lenght
- Passed by value

* Slices
.code slices.go

- Backed by arrays
- Automatically resized by append

* Maps 
Maps are the most abused and useful data structure.

.code maps.go

- no native equivalent in C
- they hold a reference to the data
- also used as sets

* Functions

.code functions.go

- multiple return values (error handling)
- first class values
- can be anonymous

.code closure.go

* Memory management in C

- heap vs stack
.code malloc.c

- efficient
- the dev is in control of what lives in the stack and what in the heap
- easy to forget the lifecycle of malloc'ed objects

* Memory management in C

.image heartbleed.png 400 _

*The*most*effective*way*to*shoot*in*your*foot*

* Memory management in Go

There are pointers too, which is good: the dev is in control of what is passed by value and what by reference 

.code pointers.go

- using escape analysis, the compiler chooses what to leave on the stack and what on the heap
- garbage collected
- pointers are references to live objects: there is no way to mess up with the memory
: differenza con altri linguaggi dove tutto e` per reference 
: no boxing

* But I really really miss pointer arithmetic!

* Unsafe package

The package name is self explanatory.
It provides Pointers.

- A pointer value of any type can be converted to a Pointer.
- A Pointer can be converted to a pointer value of any type.

	func Float64bits(f float64) uint64 {
		return *(*uint64)(unsafe.Pointer(&f))
	}

- Pointer arithmetic 

	f := unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.f))


* Nice things about GO

* It's safer

Prevents side effects related to distractions 

- assignement between different types requires explicit conversion
.code casting.c
- variables are initialized with zero values
.code initialization.c
- no pointer arithmetic
.code pointerarit.c

* (A bit) less verbose 

- No ;
- No () around ifs
- Type inference, short variable declaration
.code variable.go
- Multiple return values (also, named return values)
.code multiple.go


* (A bit) less verbose (and more readable)

- literal initializations
- Range loops (in maps, slices and strings)
.code range.go
- Can't have unused variables
- _ to say that a result is not interesting
.code ignore.go
- defer() to call finalizing operations inside a function
- no break in switch, switch cases can be conditions

* Productivity boost!

Compiling is *really* fast

.image compiling.png

* Let's talk about OOP

* User defined data structures
C structs:
.code structs.c
Go Structs
.code struct.go

* No classes in Go

_If_C++_and_Java_are_about_type_hierarchies_and_the_taxonomy_of_types,_Go_is_about_composition._ (Rob Pike)

.code embedding.go

* Go structures vs classes

- no inheritance
- no generics
- enforce composition

.image eighties.jpg 400 _

* Methods

- Just a special kind of functions (they have a receiver)
- Explicitly associated to objects or pointers

.code methods.go

; can assign methods to any type, even those you don't own

* Interfaces

- Abstract types defining a behaviour
- Satisfied implicitly 

.code interface.go

- Can be checked

.code interfaceassertion.go
: you can retro assign an interface to any object

* Encapsulation

.image encapsulation.jpeg _ 400

* Encapsulation in C

static modifier for functions and variables

- Local to a .c file
- Directly related to exported names available during linking

* Encapsulation in Go:

Every file belongs to a package

	package mypackage

	var Exported int
	var notExported string
	
- The visibility is related to the _package_
- Multiple files can belong to the same package
- The visibility is toggled by uppercasing / lowercasing 

	import "mypackage"

	var a = mypackage.Exported // ok
	var b = mypackage.notExported // compiler error 


No class related public, private.

* The worst nightmare of every (C) programmer


* 

Knock knock. 
Race condition. 
Who's there?

* Multithreading

A bug in multithreading can result in memory corruption with unexpected and unpredictable results. Moreover, it could happen in very rare situations difficult to reproduce with tests.

What's more, a wrong usage of the locking primitives can result in a deadlock of two or more threads.

*Getting*threading*right*is*difficult*

* pthread.h

Provide primitives to create and synchronize threads together.

- Mutexes
- Condition variables
- Semaphores

_Multithreading_is_today's_goto_:_
- hard to read / understand
- difficult to debug

What we need is a better solution for concurrency, easier to understand and to handle

* Enters goroutine

Goroutines are lightweight threads managed by the Go runtime.

	go myFunction()

*Why*lighter?*

- smaller (altough variable) stack
- many goroutines can be share a single os thread
- scheduling not invoked periodically but as a consequence of synchronization


_It_is_practical_to_create_hundreds_of_thousands_of_goroutines_in_the_same_address_space_


* Why they are different?

.image differentfromthreads.jpg

* Channels

A channel is a communication mechanism between two goroutines

	ch := make(chan int)

We can send values to a channel

	ch <- 23

or receive from a channel

	res := <- ch

or just check if send has happened

	<- ch

Channels can be buffered or unbuffered.
Sending on a full channel blocks the sender, receiving from an empty channel blocks the receiver.

* Goroutines are indipendent executing actors communicating via channels
.image concurrency.jpeg

Definetely easier to reason about

* An example

.play goroutine.go

* Where are my mutexes?

* Go provides synchronization primitives
- Mutexes
- RW Locks
- sync.Once

*Bonus*point:*
Race detector, just build with _-race_ flag

* Everything else

* Coding style

.image spacestabs.png 250 _

.caption Survey by [[https://stackoverflow.blog/2017/06/15/developers-use-spaces-make-money-use-tabs/][stackoverflow]] 

Go fmt formats the code in the "go way"

- easier to read
- easier to write
- no tabs vs spaces discussions!

* Building

Workspace: root tree pointed by $GOPATH variable 

	bin/
	    hello                          # command executable
	pkg/
	    linux_amd64/
		github.com/fedepaol/example/
		    stringutil.a           # package object
	src/
	    github.com/fedepaol/example/
		hello/
		    hello.go               # command source
		    stringutil.go
	    golang.org/x/image/
		bmp/
		    reader.go              # package source
		    writer.go              # package source

_Most_Go_programmers_keep_all_their_Go_source_code_and_dependencies_in_a_single_workspace_


* Building (2)

*go*build* _package_

- non main packages are compiled and thrown away
- executables are compiled and left in the current dir

*go*install* _package_

- non main packages are deployed in $GOPATH/pkg
- executables in $GOPATH/bin

*go*get* _package_ (as in github.com/fedepaol/example/hello)

- downloads the package and its dependencies
- *installs* it

* Deploying
There is no need for shared libraries. Not even libc.

The go runtime is linked together with the executable. The absence of external dependencies makes the deployement a lot easier than a C executable.

* Bells and whistles
- reflection!
- C interoperability
- rich standard library
- awesome echosystem (https://github.com/avelino/awesome-go)
- integrated testing framework
- native cpu and memory profiling
- cross compiles
- awesome linters

* Where to go from here

- Official website
.link http://golang.org

- Interactive Tutorial
.link http://tour.golang.org

- Effective go
.link https://golang.org/doc/effective_go.html

- Mailing list
.link https://groups.google.com/forum/#!forum/golang-nuts

